PackingMethod
=============
ТЕОРЕТИЧЕСКИЕ ОСНОВЫ
    
     В основе алгоритма архивации информации методом упаковки лежит идея об уменьшении количества бит, отводимых для кодирования одного символа, если это возможно. 

    Таким образом, архивация методом упаковки состоит в следующем:

Для входных данных формируется алфавит, включающий в себя все различные  символы по одному разу.
Определяется минимальное число бит, необходимое для кодирования одного символа полученного алфавита.
Создаётся новая кодировочная таблица, позволяющая однозначно декодировать входные данные.
В соответствии с полученной кодировочной таблицей, входные данные кодируются и на выходе получается заархивированная информация.
    
    Для последующего декодирования информации, заархивированный файл должен содержать кодировочную таблицу и в некоторых реализациях иную информацию, необходимую для однозначного декодирования. Этот факт является ключевым при анализе эффективности алгоритма. В случае если входные данные содержат все возможные символы таблицы ASCII, размер кодировочной таблицы будет равен размеру таблицы ASCII и, соответственно, на кодирование каждого символа нам потребуется 8 бит. Таким образом, мы не просто не получим никакого выигрыша в сжатии, но ещё и увелеичим размер входных данных за счёт хранения информации для декодирования. Аналогичный эффект будет в случае, если размер входных данных составляет всего несколько байт (размер информации для декодирования превысит размер входных данных).

Необходимо учесть, что ситуации, описанные выше, связаны в первую очередь с шифрованием больших текстовых или бинарных файлов, где зачастую используются все символы таблицы ASCII. Если же архивировать информацию, в которой используется не весь алфавит и частота повторения одинаковых символов велика, рассматриваемый алгоритм будет оптимальным решением в силу своей простоты.


РЕШЕНИЕ ЗАДАЧИ
    
    Как было сказано выше, первым этапом реализации алгоритма является формирование алфавита, в соответствии с которым будет получена кодировочная таблица. Рационально сформировать её в виде множества пар “ключ:значение”, где ключ - номер символа в таблице ASCII, значение - номер символа в нашей таблице (нумерацию начинаем с 0). Таким образом, на хранение каждой пары будет отводиться 2 байта и суммарно вся таблица займёт 2*k байт, где k - число различных символов, то есть размерность алфавита. При чём минимальный объём кодировочной таблицы Iтабл min = 2 байта (в случае с k = 1) и Iтабл max = 512 байт (в случае с k = 256).  

    Также для последующего декодирования необходимо хранить количество пар “ключ:значение”, которое, как мы выяснили, может варьироваться от 1 до 256, т.е. для хранения нам достаточно Iразмер таблицы = 1 байт.

    Ещё 1 байт отведём в файле для хранения числа бит, которое необходимо для кодирования символа в новой кодировочной таблице. Т.о. Iвес символа = 1 байт.

    Для однозначного декодирования архива необходимо выделить в файле ещё Iспец = 1 байт для хранения специального значения. Рассмотрим на небольшом примере его назначение. Пусть нам дана входная строка “ab”. В таком случае “a” будет кодироваться 0, а “b” будет кодироваться 1. Таким образом, в зашифрованном виде строка примет следующий вид: 01, что при переводе в десятичную систему для последующей записи в файл даёт число 1. Но зашифровав, например, строку “aab” (001), в десятичном представлении получится снова число 1, то есть заархивированные файлы будут идентичны и при декодировании информации невозможно будет установить, что же было закодировано изначально. “Сппециальное” число хранит количество символов, которые дополняют зашифрованную строку до полного байта. То есть для строки “ab” значение этого числа будет 6, для строки “aab” - 5, что уже позволит декодировать информацию однозначно.
Алгоритм неспоредственно кодирования рассмотрим на примере:
Закодируем с помощью алгоритма упаковки строку “mama mila ramu”.
Алфавит будет состоять из символов {‘m’, ‘а’, ‘ ‘, ‘i’, ‘l’, ‘r’, ‘u’}, k = 7. 
Минимальное число бит, которым возможно закодировать 7 различных символов, равно I = 3.
Кодировочная таблицы примет следующий вид:
109 (m) : 0
97   (a)  : 1
105 (i)   : 2
108 (l)   : 3
114 (r)   : 4
117 (u)  : 5
В двоичном представлении в соответствии с числом бит, выделяемым под кодирование каждого символа, получим:
0 = 000; 1 = 001; 2 = 010; 3 = 011; 4 = 100; 5 = 101. 
Далее сформируем строку, в которой каждый символ исходной строки будет записан в двоичном представлении: 00.00010000.01010000.01110000.10101010.01000110
В данном случае описанное выше “специальное” число равно 6.
Разобьём строчку на байты, начиная с конца, и переведём каждый байт в десятичную СС: 0 16 80 112 170 70. Полученная информация и будет последовательно записана в файл.

    Реализация алгоритма происходила на языке C++. В качестве параметров командной строки на вход программе подаётся имена входного и выходного файлов. В случае, если имя выходного файла не задано, оно будет являться результатом конкатенации имени входного и суффика “.pack”. 
Для определения и хранения алфавита и связанной с ним информации был реализован класс Alphabet, в котором с использованием потоков стандартной библиотеки C++ происходит обработка входных данных. Здесь же определяется число бит, необходимое для кодирования каждого символа. Для хранения алфавита используется std::vector<char>.
Сам алгоритм сжатия данных реализован в классе Compressor. При вызове public метода Compressor::startCompression последовательно выполняются следующие действия, реализованные в private методах класса:
Создаётся экземпляр класса Alphabet. Для сформированного алфавита определяется кодировочная таблица, хранящаяся в контейнере std::map<char, char>.
Следующим шагом происходит запись в файл размера таблицы, самой таблицы, количества бит, необходимых для кодирования одного символа, и “специального” числа, т.е. всей служебной информации.
Далее происходит повторная обработка входного файла и в соответствии с кодировочной таблицей формируется закодированная строка, состоящая из “0” и “1”.
Финальным шагом работы класса Compressor является обработка закодированной строки. При проходе с конца в начало строка разбивается на байты, каждый из которых переводится в десятичную систему счисления и заносится в массив. Т.к. обработка строки производилась с конца, массив нужно инвертировать. Полученный массив последовательно записывается в выходной файл.
    
    В функции main происходит создание экземпляра класса Compressor, конструктор которого принимает ссылки на входной и выходной файл, и запуск метода Compressor::startCompression. Для анализа эффективности алгоритма, происходит подсчёт размеров входного и выходного файлов и определение времени работы программы.


